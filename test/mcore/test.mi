
language MCore

// Functions with lists
let nil = lam c:a. lam n:a. n
let isnil = lam l:[a]. l (lam h:Bool. lam t:Bool. false) true
let cons = lam h:Int. lam t:[Int]. lam c:a->a->a. lam n:Bool. c h (t c n)
let head = lam l:[Int]. l (lam h:Int.lam t:[Int].h) false
let tail = lam l:[Int]. lam c:a->a->a. lam n:Bool. l (lam h:Int.lam t:[Int].lam g:a->a->a. g h (t c)) (lam t:[Int].n) (lam h:Int.lam t:[Int].t)

utest true (isnil nil)
utest false (isnil (cons 2 (cons 3 nil)))
utest true (isnil (tail (tail (cons 2 (cons 3 nil)))))
utest 2 (head (cons 2 (cons 3 nil)))

let pow = fix (lam pow:(Int->Int->Int). lam x:Int. lam n:Int.
           ifexp (leqi n 1)
              (lam _:a. x)
              (lam _:a. muli x (pow x (subi n 1)))
           )


let fib = fix (lam fib:Int->Int. lam n:Int.
	     ifexp (eqi n 1)
		(lam _:a. 1)
	        (lam _:a. ifexp (eqi n 2)
		          (lam _:a. 2)
	                  (lam _:a. addi (fib (subi n 1)) (fib (subi n 2)) )	
	        )
		
	   )


// Function to estimate a fibonacci number fib(n).
// Returns (fib(prev), fib(curr))
let fib2 = fix (lam fib2:Int->[Int]. lam n:Int.
    ifexp (leqi n 2)
    (lam _:a. (cons (subi n 1) (cons n nil)))
    (lam _:a.
	let res = fib2 (subi n 1) in
	let fibn_2 = head res in
	let fibn_1 = head (tail res) in 
	(cons fibn_1 (cons (addi fibn_1 fibn_2) nil))
    )
)

let fib2_fin = lam n:Int.
    let res = (fib2 n) in
    (head (tail res))
    
utest true (eqi 13 (fib 6))	
utest true (eqi 4 (pow 2 2))	
utest true (eqi 13 (fib2_fin 6))	

// Lazy fib
let fiblazy = fix (lam fiblazy:Int->Int. lam n:Int.
	     ifexp (leqi n 2)
		(lam _:a. n)
	        (lam _:a.
		     let n1 = fiblazy (subi n 1) in
		     let n2 = later 0.1 (lam _:a. fiblazy (subi n 2)) in
	             (addi n1 (now n2))
	        )
		
	   )

utest true (eqi 13 (fiblazy 6))	

let mapplus = fix (lam mapplus:[Int]->Int->[Int]. lam l:[Int]. lam n:Int.
	     		ifexp (isnil l)
			(lam _:a. nil)
	        	(lam _:a. 
				cons (addi (head l) n) (mapplus (tail l) n) 
	        	)
		
	   	)

utest true (isnil (mapplus nil 5))
utest 7 (head (tail (mapplus (cons 3 (cons 2 (cons 1 nil))) 5)))


let range = fix (lam range:Int->[Int]. lam n:Int.
	     ifexp (eqi n 0)
		(lam _:a. nil)
	        (lam _:a. 
			cons n (range (subi n 1))
	        )
		
	   )

let erange = fix (lam erange:Int->Int->[Int]. lam n:Int. lam e:Int.
	     ifexp (eqi n e)
		(lam _:a. nil)
	        (lam _:a. 
			cons n (erange (addi n 1) e)
	        )
		
	   )


utest 2 (head (erange 2 10))
utest 7 (head (tail (mapplus (range 3) 5)))


let erev = fix (lam rev: [Int] -> [Int] -> [Int]. lam l:[Int]. lam res: [Int].
		ifexp (isnil l)
		(lam _:a. res)
		(lam _:a. rev (tail l) (cons (head l) res))
		)


utest 1 (head (erev (range 7) nil))
utest 7 (head (erev (erev (range 7) nil) nil))



//let bsortinner = fix (lam bsortinner: [Int] -> [Int] -> [Int]. lam l:[Int]. lam acc: [Int].
let bsinner = fix (lam bsinner: [Int] -> [Int] -> [Int]. lam l:[Int]. lam acc: [Int].
		ifexp (isnil l)
		(lam _:a. acc)
		(lam _:a. 
			let t = tail l in
			ifexp (isnil t)
			(lam _:a. cons (head l) acc)
			(lam _:a. 
				let hl = head l in
				let ht = head t in
				ifexp (gti hl ht)		
				(lam _:a. bsinner (cons hl (tail t)) (cons ht acc))
				(lam _:a. bsinner t (cons hl acc))
			)
		)
		)

let bsouter = fix (lam bsouter: [Int] -> [Int] -> [Int]. lam l:[Int]. lam acc: [Int].
		ifexp (isnil l)
		(lam _:a. acc)
		(lam _:a. 
			let nlist = bsinner l nil in
			ifexp (isnil nlist)
			(lam _:a. acc)
			(lam _:a. 
				let hl = head nlist in
				let tl = tail nlist in
				bsouter (erev tl nil) (cons hl acc)
			)
		)
		)



let appendint = fix (lam appendint: [Int] -> [Int] -> [Int]. lam l1:[Int]. lam l2:[Int].
		ifexp (isnil l1)
		(lam _:a. l2)
		(lam _:a. 
			appendint (tail l1) (cons (head l1) l2)
		)
		)

let append = lam l1:[Int]. lam l2:[Int].
		appendint (erev l1 nil) l2

let len = fix (lam len: [Int] -> Int. lam l:[Int].
		ifexp (isnil l)
		(lam _:a. 0)
		(lam _:a. (addi (len (tail l)) 1) )
		)


let list = append (erange 4 11) (erange 0 3)

utest 5 (len (range 5))
utest 4 (head (append (erange 4 11) (range 3)))
utest 10 (len (append (erange 4 11) (range 3)))

utest 7 (head ( bsinner (erev (range 7) nil) nil ))
utest 1 (head ( bsouter (erev (range 7) nil) nil ))

utest 0 (head (bsouter list nil))
utest 2 (head (erange 2 10))
